# Register based virtual machine.

A register based VM uses dedicated addresses to do IO such as printing and such. It can fetch data from a memory location and store it out. A register based VM can also do "built in" functions for things line printing like the ones designed for and interpreter. 

[TOC]

## General

This VM is a register based design that has built in augmentations for doing system level stuff. All of the registers will be 32 bits, which is the size of a pointer on my machine.  No memory partitioning or protection is implemented. There are some hidden registers and associated instructions that manage things like where memory is located. 

The programming model and instruction set is designed to make it easy to serialize a program and run it on the VM. A program compiled to the VM will run on any platform that has a VM implemented for it.

Atomic test-and-decrement instructions implement semaphores.

There are dedicated instructions for doing arithmetic on floats, integers, and unsigned values.

All registers can be operands of an arithmetic operation or a pointer.

There are registers that have the physical location of the core memory. There are 4 types of memory. Each of these has its own internal functionality that is set up before the virtual machine starts. Memory addresses in the virtual machine are offsets from zero, which is added to the system address stored in these registers. Which segment the instruction refers to is encoded into the instruction.

* Read/write memory, where the program data is stored. Code cannot be fetched from this segment.
* Read only memory where the program instructions are stored.
* Stack space. Stack space is 64 bits and is stored in a segment other than the one for read/write data.
* Read-only constant data allocations. This segment is for things like string constants.

Threading is implemented by the program that is running, but the instructions to save and restore the state of the VM are provided. The system interface of the VM is implemented using the concept of software traps. Re-entering a software trap is prevented by a flag. When the flag is set, the trap is ignored.  (((A better mechanism requires research. Traps should be queued and entered in the order they are called.))) A trap automatically saves the state of the VM on the stack when entered.

There is no notion of a "privileged" mode. All instructions, including those that operate on exception and trap vectors run at the same privilege level.

## Trap vectors

Traps are the mechanism that is used to implement interfacing the program running in the VM to outside code. Trap vectors are pointers to functions that exist outside of the code running in the VM. The trap number is equivalent to a void* (64 bits on my machine) and points to the entry of the system interface function, which has direct access to the register set of the VM to allow it to get parameters and post a return value. The called external function does not have access to the memory space of the VM. 

## Exception vectors

A table exists for exception vectors. These are different from trap vectors in that the code is run by the VM. Traps can be called inside an exception as anywhere else. There are dedicated vectors for runtime errors generated by the VM, such as divide by zero and such.

### System exceptions

These are how the VM implements catching signals from the operating system. These are UNIX oriented with modifications as required. The code that these signals cause to be executed is defined for the VM to run, but may include traps to run code external to the VM.

|  Sig name   | Sig number | Explanation                                                  |
| :---------: | :--------: | :----------------------------------------------------------- |
| **SIGHUP**  |     1      | The **HUP** signal is sent to a process when its controlling terminal is closed. It was originally designed to notify the process of a serial line drop (**HUP** stands for "Hang Up"). In modern systems, this signal usually means  that the controlling pseudo or virtual terminal has been closed. Also used to reload configurations, etc. |
| **SIGINT**  |     2      | The **INT** signal is sent to a process by its controlling terminal when a user wishes to *interrupt* the process. This signal is typically initiated by pressing Control-C,  but on some systems, the "delete" character or "break" key can be used. |
| **SIGQUIT** |     3      | The **QUIT** signal is sent to a process by its controlling terminal when the user requests that the process perform a core dump, however, note that the core dump will be of the VM, not the running program in the VM. |
| **SIGILL**  |     4      | Illegal instruction. The **ILL** signal is sent to a process when it attempts to execute a malformed, unknown, or privileged instruction. |
| **SIGTRAP** |     5      | Trace trap. The **TRAP** signal is sent to a process when a condition arises that a debugger is tracing â€” for example, when a particular function is executed, or when a particular variable changes value. |
| **SIGABRT** |     6      | Abort process. **ABRT** is usually sent by the process itself, when it calls the **abort()** system call to signal an abnormal termination, but it can be sent from any process like any other signal. **SIGIOT** is a synonym for SIGABRT. |
| **SIGBUS**  |     7      | The **BUS** signal is sent to a process when it causes a bus error, such as an incorrect memory access alignment or non-existent physical address. In Linux, this signal maps to SIGUNUSED, because memory access errors of this kind are not possible. |
| **SIGFPE**  |     8      | Floating point exception. The **FPE** signal is sent to a process when it executes an erroneous arithmetic operation, such as division by zero. |
| **SIGKILL** |     9      | Forcefully terminate a process. Along with **STOP**, this is one of two signals which cannot be intercepted, ignored, or handled by the process itself. |
| **SIGUSR1** |     10     | User-defined signal 1. This is one of two signals designated for custom user signal handling. |
| **SIGSEGV** |     11     | The **SEGV** signal is sent to a process when it makes an invalid  virtual memory reference, or segmentation fault, i.e. when it performs a segmentation violation. |
| **SIGUSR2** |     12     | User-defined signal 2. This is one of two signals designated for custom user signal handling. |
| **SIGPIPE** |     13     | The **PIPE** signal is sent to a process when it attempts to write to a pipe without a process connected to the other end. |
| **SIGALRM** |     14     | The **ALRM** signal notifies a process that the time interval specified in a call to the **alarm()** system function has expired. |
| **SIGTERM** |     15     | The **TERM** signal is sent to a process to request its termination. Unlike the **KILL** signal, it can be caught and interpreted or ignored by the process.  This signal allows the process to perform nice termination releasing  resources and saving state if appropriate. It should be noted that **SIGINT** is nearly identical to **SIGTERM**. |



## Registers

All registers are the same size as a pointer on the machine that the VM runs on. On my machine, that is 64 bits. There are 32 (numbered 0x01-0x1F) general purpose registers, as well as the usual flags, stack, and instruction registers. Any general purpose register can be used for anything that any other register can be used for. The instruction and stack registers can be referenced by instructions, but cannot be updated directly. The flags register is accessed by dedicated instructions.

**NOTE** Change register types from pointing to different memory to having the address determine where the pointer points.

### Operand types

The register number is given by the mask 0x1F and the register type is given by the mask (0x07 << 5). Register number 0x00 is reserved for immediate operands. An immediate operand can be a a symbol or a literal number, or an expression. An expression must evaluate to a value at compile time. If a value must be calculated, then that must be done using instructions. Same is true of symbols. When a symbol is encountered, then it is evaluated for a value and treated as a value or a pointer accordingly.

```C
typedef struct {
    unsigned char is_immediate;
    unsigned char type;
    unsigned char number;
} operand_type_t;

#define EMIT_OPERAND_SPEC()  \
    emit_opcode((unsigned char) \
        ((operand_spec.is_immediate & 0x01) << 7| \
        (operand_spec.type & 0x07) << 6| \
        operand_spec.number & 0x0F))
```

If is_immediate is set, then the 

* 0x00 Operand is an immediate value.
  * 0x10 Operand size is 
* 0x01 Operand is a non-pointer
* 0x02 Operand is a pointer



* 0x00 Register is an index to the stack.
* 0x01 Register has an index into code memory, i.e. for a branch.
* 0x02 Register has a pointer to read/write memory
* 0x03 Register has a pointer to constant memory
* 0x04 Register place holder is an immediate value or a reference to memory
  * 0x01 Immediate is 8 bits
  * 0x02 immediate is 16 bits
  * 0x03 immediate is 32 bits
  * 0x04 immediate is 64 bits.
  * 0x05 immediate is a pointer
* 0x05 Register has a literal float value
* 0x06 Register has a literal integer value
* 0x07 Register has a literal unsigned value

### Flags register

The flags register has single bit values that are set by compare instructions and cleared by branching instructions. There is also a set of instructions that can be used to set and clear the flags explicitly.

#### Flags

* Zero - Set when a compare is equal or an arithmetic operation results in zero. Arithmetic operations on floats never sets this flag.
* Negative - Set when the result of an instruction is negative. Operations on signed and floats only.
* Unsigned Overflow - AKA Carry. Set when the current operation will not fit into the destination operand.
* Signed Overflow - Set when an arithmetic operation will not fit into its destination operand. 
* Trap - Set when a TRAP instruction is executed. While this flag is set, the TRAP instruction will be ignored except for setting the Trap Missed flag. This flag can be cleared using the CLT instruction and it is cleared automatically when a TRET instruction is encountered.
* Exception - Set when an exception is entered. When this flag is set, no further exceptions can be entered. This flag is cleared by the ERET instruction.
* Trap missed - This flag is set when a trap is entered and the trap flag is already set. This is used to flag an error, if needed.
* Exception missed - This flag is set when an exception is entered (also from external source) and the exception flag is already set. 

#### Condition codes

There are 14 condition codes that are encoded into some instructions. See below

| Condition |  N   |  Z   |  C   |  V   | Desc                                                   |
| :-------: | :--: | :--: | :--: | :--: | :----------------------------------------------------- |
|    EQ     |  x   |  1   |  x   |  x   | Equal                                                  |
|    NE     |  x   |  0   |  x   |  x   | Not equal                                              |
|    CS     |  x   |  x   |  1   |  x   | Unsigned higher or same (or carry set).                |
|    CC     |  x   |  x   |  0   |  x   | Unsigned lower (or carry clear).                       |
|    MI     |  1   |  x   |  x   |  x   | Negative. The mnemonic stands for "minus".             |
|    PL     |  0   |  x   |  x   |  x   | Positive or zero. The mnemonic stands for "plus".      |
|    VS     |  x   |  x   |  x   |  1   | Signed overflow. The mnemonic stands for "V set".      |
|    VC     |  x   |  x   |  x   |  0   | No signed overflow. The mnemonic stands for "V clear". |
|    HI     |  x   |  #   |  #   |  x   | Unsigned higher. (C == 1) && (Z == 0)                  |
|    LS     |  x   |  #   |  #   |  x   | Unsigned lower or same. (C == 0) \|\| (Z == 1)         |
|    GE     |  #   |  x   |  x   |  #   | Signed greater than or equal. N == V                   |
|    LT     |  #   |  x   |  x   |  #   | Signed less than. N != V                               |
|    GT     |  x   |  #   |  x   |  #   | Signed greater than. (Z == 0)  &&  (N == V)            |
|    LE     |  x   |  #   |  x   |  #   | Signed less than or equal. (Z == 1) \|\| (N != V)      |
|    TE     |      |      |      |      | Trap has been entered                                  |
|    EE     |      |      |      |      | Exception has been entered                             |

Additional flags are present that are set when a trap or a exception are in progress.

## Instruction set

NOTE: This does not match the parser. I have added registers.

Instructions are variable length and based upon an 8 bit word, followed by operands. The number and type of the operands is specified by the instruction. The VM has a capability to read words, from 8 to 64 bits, from the instruction stream. In cases where it is required, a value to be manipulated is copied to a hidden register.

### Group 1 - Data Manipulation

#### (T)ADD, (T)SUB, (T)MUL, (T)DIV, (T)MOD

These arithmetic instructions are given by type. Types are integer, unsigned, and float. The compiler is responsible for making sure that the types are compatible. These instructions take exactly 3 operands. The first operand must be a register and holds the results of the operation. The 2nd and 3rd operands are the left and right operands respectively. The left and right operands can be any of the following:

* Register with the value to use.
* Register with a pointer to the value to use. (see memory types above)
* An immediate register sized value.

The (T) prefix indicates the type of operation to perform as follows

* Integer = (I)
* Unsigned = (U)
* Float = (F)

The operands are in "assignment" order. For example IADD R0, R1, R2 is equivalent to R0=R1+R2, where R1 and R2 are unsigned. R0 takes the implicit attribute of being unsigned. When a register is specified as (for example) unsigned, the value in that register is treated as unsigned, no matter what the actual contents are. Adding a actual unsigned and a float, for example, produces invalid results.

##### Flags

* If the result of the operation is zero, then the zero flag is set, else it is cleared.
* If the operation is float or integer and overflows, then the signed overflow is set, otherwise, it is cleared.
* If the operation is unsigned and overflows, then the carry flag is set, otherwise it is cleared.
* If the operation is signed and produces a negative value, then the negative flag is set, otherwise it is cleared.

#### FTU, FTI, ITF, ITU, UTF, UTI

These instructions convert a register value from one type to another. For example, FTU converts the register to from float to unsigned by taking the absolute value and then converting the type, such that a number such as -12.123 first converts to 12.123 and then to 12. Converting the float to an integer is a simple C-like cast that results in -12. Converting an integer to unsigned takes the absolute value such that -12 becomes 12. Converting a number such as 0xF000 to an int becomes 61440 via a simple cast. (just like C)

##### Flags

This instruction has no effect on the flags.

#### (T)NEG

This is arithmetic negate. This instruction takes exactly one register operand. The register may contain the value to use, or it may be a pointer to the value to use. The value in the register is negated as one would expect. Note that using INEG on a float or FNEG on an integer produces invalid results. It's up to the compiler to use the proper type of instruction for the type.

##### Flags

* If the value was negative and was made positive, then the N flag is cleared.
* If the value was positive and made negative then the N flag is set.
* Attempting to negate a zero value sets the zero flag, else the zero flag is cleared.

See ADD et. al.

#### INC, DEC

These instructions increment or decrement registers. They accept one operand that must be a register. The value in the register is taken to be a signed integer. 

##### Flags

* If the result is zero, then the zero flag is set, otherwise it is cleared.
* If the result is negative, then the negative flag is set, otherwise it is cleared.
* If the result wraps a positive value, then the overflow flag is set, otherwise it is cleared.

#### SHL, SHR, ROL, ROR, 

These are bitwise shift and rotate instructions. These take exactly two operands. The left operand must be a register. They treat the register operand as unsigned. The right operand is unsigned and may be a register or an immediate value that is less than the register size, that is the immediate will fit into a byte. The result of the operation is in the left operand.

##### Flags

* If the result is zero, then the zero flag is set.
* If a shift operation looses a set bit, then the carry flag is set.
* If the high bit is set, then the overflow (V) flag is set.

#### AND, OR, XOR

These are bitwise logical operations. They takes exactly three operands which are treated as unsigned. The first operand is treated as unsigned and must be a register. The other two operands may be values in registers, pointers in registers, or register sized immediate values. The result is placed in the first operand.

##### Flags

* If the result is zero, then the zero flag is set, else it is cleared.

#### NOT

This produces the 2's compliment of the operand. This instruction accepts exactly one operand that must be a register. The result is placed in the register operand.

##### Flags

* If the result is zero, then the zero flag is set, else it is cleared.

### Group 2 - Comparison

#### CMP

This instruction compares the magnitude of two operands. It takes exactly two operands. Both operands must be values in registers. The flags are updated as a result of subtracting the right operand from the left operand. The compiler must take care that the operands type match. The VM does no checking for this.

##### Flags

* If the result is zero, then the zero flag is set, otherwise it is cleared.
* If the result is negative, then the negative flag is set, otherwise it is cleared.

#### TST

This instruction does a bitwise compare of the two operands by ANDing them and then updates the flags according to the result. This instruction accepts exactly two operands that must be values in registers. There is no checking to see if the values have a particular type, so the compiler must make sure that the operands are valid for a logical AND operation.

##### Flags

* If the result is zero, then the zero flag is set, otherwise, it is cleared.

### Group 3 - Moving data around

#### LOAD

This instruction accepts exactly two operands. The first operand is a register and the second operand may be a value in a register, a pointer in a register, a pointer in a register with a 8 or 16 bit offset, or a register sized immediate value. The value specified in the second operand is loaded into the register.

#### STORE

This instruction accepts exactly two operands. The first operand is a register containing a value. The second operand is the destination to place the value into. The second operand may be a register, a register containing a pointer, a register containing a pointer with an offset, or a literal pointer into read/write memory.

#### MOV(S)

This instruction moves a value from one place in memory to another. It accepts two operands, both of which must be registers with pointers. The suffix (S) gives the size of the move in bits. For example, ```MOV8 R0,R1``` Moves one byte from the pointer specified in R1 to the pointer specified by R0. Valid suffixes are 8, 16, 32, and 64.

#### MOVB(S)

This instruction moves a block of values from one location in memory to another. It accepts exactly three operands, all of which must be registers. The first and seconds registers must contain pointer values. The third register contains the number of words to be copied by the instruction. The size of the move is given by the (S) suffix. See MOVS above.

#### PUSH, POP

These instructions give access to the stack. The have exactly one operand that can be the value in a register or a register sized immediate value. There is no differentiation of type for these instructions.

#### Group 4 - Branching

The (C) suffix refers to the conditions under which the branch will be taken. See the section about Condition Codes above. When the condition is met, the branch is taken, otherwise it is ignored. When any branch is taken because of these instructions, the flags register is cleared. If the branch is not taken then the flags are not cleared. 

#### JMP(C)

This instruction conditionally jumps to an address specified by a single operand. The operand specifies an index, by bytes, into the instruction memory. If the branch is taken all flags are cleared. This differers from CALL only in that it does not change the stack if the branch is taken. The operand can be a value in a register, an immediate value, a value in a register with an offset, or an immediate value with an offset. 

#### CALL(C)

This instruction conditionally jumps to an address specified by a single operand, after pushing the current instruction pointer onto the stack. The operand specifies an index, by bytes, into the instruction memory. If the branch is taken all flags are cleared. The operand can be a value in a register, an immediate value, a value in a register with an offset, or an immediate value with an offset. 

#### EXCALL(C)

This instruction conditionally jumps to an address specified by a single operand, after pushing the current instruction pointer onto the stack. The operand the address of an external routine. If the branch is taken all flags are cleared. The operand may be a register or an immediate literal address. 

#### RET(C)

This instruction conditionally returns from a previous call by popping the top of the stack into the instruction pointer register. It does not have any operands.

#### TRAP(C)

This instruction conditionally enters a trap. A trap is the formal interface for external functions. This accepts exactly one argument that is a register sized immediate value which is a pointer into the VM's program space, where the external function is defined. It is expected that there will be a stub of VM assembly that interfaces registers to parameters and return values. When instruction is executed, the current instruction pointer is pushed on the stack. Traps are returned by executing the RET(C) instruction. The TRAP(C) instruction sets the trap flag in the flags register. If the trap flag is set then ant subsequent traps are excluded and the trap ignored flag is set. In general having the trap ignored flag set is an error. Executing a RET(C) instruction clears the trap flag, or it can be cleared with the CTR instruction. (see below). When this is entered, the trap missed flag is cleared.

#### TRET(C)

This is just like the RET(C) instruction except that it also clears the trap flag.

#### RAISE(C) 

This instruction raises an exception from inside the code executing on the VM. Much of this functionality is TBD. It is intended that this will be used to implement high level exceptions. When this is entered, the exception missed flag is cleared.

#### ERET(C)

This instruction clears the exception entered flag. Other than that, it's just like the RET(C) instruction. 

### Group 5 - Special/Administrative 

#### NOP

No operation. This instruction can be used for padding or to introduce a very small delay in execution. This instruction has not operands.

#### STZ, CLZ

Set the zero flag or clear the zero flag. No operands.

#### STC, CLC

Set the carry flag or clear the carry  flag. No operands.

#### STN, CLN

Set the negative flag or clear the negative flag. No operands.

#### STV, CLV

Set the overflow flag or clear the overflow flag. No operands.

#### STT, CLT

Set the trap flag or clear the trap flag. No operands.

#### STE, CLE

Set the exception flag or clear the exception flag. No operands.

#### PAUSE

Pause the execution of the VM instructions and wait for an external event. No operands.

#### RESUME

Resume the execution of the VM instructions. No operands. The PAUSE and RESUME instructions are tied to the USR1 signal by default.

#### END

End the VM and exit the program to the operating system.

# Assembler

The assembler takes an assembler input file and converts it to byte codes suitable for the VM to run.  The assembler handles reserving all of the memory areas and placing data in them as needed. It also handles simple macros and symbols to ease creating a program in pure assembly.

# Disassembler

The disassembler takes a previously assembled file and turns it back into source code.

# Debugger

The debugger has a specially compiled VM that has the hooks in it to allow things like watches and single-stepping through a program at the assembly level.











